---
title: "variance_analysis_isoforms.Rmd"
author: "Kristen Dang"
date: "December 19, 2014"
output: html_document
---

```{r message=FALSE,warning=FALSE}
library('synapseClient')
synapseLogin()
library(ggplot2)
library(scales)
library(lubridate)
library(edgeR)

library('rGithubClient')
sageCode = getRepo(repository="kkdang/sage-data-analysis")
sourceRepoFile(sageCode, "rnaseq_analysis_functions.R")
setwd('/Users/kristen/Computing/cranio/')
cutoff = 0.01
```


Alignment results
```{r cache=TRUE}
alignEntity = synGet('syn2820392')
align = read.csv(getFileLocation(alignEntity))
colnames(align)
```


Sample-level expression values
```{r}
# Fix the sample names of the estimated read count data
lookupEnt = synGet("syn2770057")
lookup = read.csv(getFileLocation(lookupEnt))
clinicalEntity = synGet('syn2731158')
clinicalData = read.csv(getFileLocation(clinicalEntity))

noMatch = which(is.na(match(lookup$UDF.Investigator.Sample.Name, clinicalData$Px.Code)))
lookup[noMatch,]

lookupRev = lookup
lookupRev$UDF.Investigator.Sample.Name = as.character(lookup$UDF.Investigator.Sample.Name)
lookupRev$UDF.Investigator.Sample.Name = replace(x=lookupRev$UDF.Investigator.Sample.Name, list=noMatch, values=c("1071", "1059", "1075"))
noMatch2 = which(is.na(match(lookupRev$UDF.Investigator.Sample.Name, clinicalData$Px.Code)))
rm(noMatch, noMatch2, lookup, lookupEnt)
```


Clinical and experimental data
```{r}
casesEntity = synGet('syn2776535')
cases = read.delim(getFileLocation(casesEntity), head = FALSE)[,1]
controlsEntity = synGet('syn2776533')
controls = read.delim(getFileLocation(controlsEntity), head = FALSE)[,1]


fixdate=function(inSplitDate){
  if (as.numeric(inSplitDate[3]) < 15) {inSplitDate[3] = paste("20", inSplitDate[3], sep = "")}
  outDate = paste(inSplitDate[1],inSplitDate[2], inSplitDate[3], sep="/")
  return(outDate)
}
cleanUpDates=function(inDateData){
  splitDates = strsplit(as.character(inDateData),split="/")
  fixedDates = sapply(splitDates,fixdate)
  return(as.Date(mdy(fixedDates)))
}

```


Function to generate data object
```{r}
generateDataAndClinicalObj=function(synId){
  dataEntity = synGet(synId) # estimated Reads
  library('R.utils')
  gunzip(getFileLocation(dataEntity),overwrite=TRUE)
  x = unlist(strsplit(getFileLocation(dataEntity), split = '.gz'))
  detach("package:R.utils", unload=TRUE)
  estReads = read.csv(x, row.names = 1)
  
  
  colnames(estReads) = lookupRev$UDF.Investigator.Sample.Name[match(colnames(estReads), paste("X", lookupRev$Sample.Name,sep = ""))]
  casesStatus = rep("case", ncol(estReads))
  casesStatus[which(colnames(estReads) %in% paste("X", controls, sep=""))] = "control"

  
  data.dge = DGEList(counts=estReads,group=factor(casesStatus),remove.zeros=TRUE)
  
  # Remove clinical data for samples that don't have matching seq data.
  noMatch = which(is.na(match(clinicalData$Px.Code, colnames(data.dge))))
  clinicalDataR = clinicalData[-noMatch,]
  
  # clean up date data
   x = cleanUpDates(clinicalDataR[,8])
  clinicalDataR[,8] = x
  x = cleanUpDates(clinicalDataR[,9])
  clinicalDataR[,9] = x
  x = cleanUpDates(clinicalDataR[,12])
  clinicalDataR[,12] = x
  x = cleanUpDates(clinicalDataR[,13])
  clinicalDataR[,13] = x
  x = cleanUpDates(clinicalDataR[,14])
  clinicalDataR[,14] = x
  
  return(list(DGE=data.dge, VARS=clinicalDataR))
}

```


Function to make PC datasets with different filters 
```{r}
proteinCoding_transcripts = getByBiotype(biotype = 'protein_coding',gene = FALSE)

generate_PCA_datasets=function(in.dge){
  
  #### Make several filtered datasets ####
  data_palx.dge = filterByFractionPresent(in.dge,fraction=0.05)
  data_palx.dge = calcNormFactors(data_palx.dge)
  
  ## All data, PALO
  palo.dge = calcNormFactors(in.dge)
  
  ## PALX=5%, mincount = 2
  palx.dge = filterByFractionPresent(in.dge,fraction=0.05,minCount=2)
  palx.dge = calcNormFactors(palx.dge)
  
  ## PALX=30%, mincount = 2
  palx30.dge = filterByFractionPresent(in.dge,fraction=0.30,minCount=2)
  palx30.dge = calcNormFactors(palx30.dge)
  
  ## Protein-coding genes, PALO
  b = as.list(rownames(in.dge))
  strippedNames = sapply(b,function(x){unlist(strsplit(as.character(x), split = "[.]"))[1]})
  
  pc.dge = in.dge[which(strippedNames %in% proteinCoding_transcripts[,1]),]
  pc_palo.dge = calcNormFactors(pc.dge)
  
  ## Protein-coding genes, PALX, mincount = 2
  pc_palx_mincount2.dge = filterByFractionPresent(pc_palo.dge,fraction=0.1,minCount=2)
  pc_palx_mincount2.dge = calcNormFactors(pc_palx_mincount2.dge)
  
  ## Protein-coding genes, PALX=20%, mincount = 2
  pc_palx20_mincount2.dge = filterByFractionPresent(pc_palo.dge,fraction=0.2,minCount=2)
  pc_palx20_mincount2.dge = calcNormFactors(pc_palx20_mincount2.dge)

  
  
  ### PCA via SVD on standardized,centered cpm expression values ####
  par(mfrow = c(3,3))
  palo.prc = prcomp(cpm(palo.dge,normalized.lib.sizes=TRUE),center=TRUE,scale=TRUE)
  screeplot(palo.prc)
  
  palx30.prc = prcomp(cpm(palx30.dge,normalized.lib.sizes=TRUE),center=TRUE,scale=TRUE)
  screeplot(palx30.prc)
  
  pc_palo.prc = prcomp(cpm(pc_palo.dge,normalized.lib.sizes=TRUE),center=TRUE,scale=TRUE)
  screeplot(pc_palo.prc)
  
  pc_palx.prc = prcomp(cpm(pc_palx_mincount2.dge,normalized.lib.sizes=TRUE),center=TRUE,scale=TRUE)
  screeplot(pc_palx.prc)
  
  pc_palx20.prc = prcomp(cpm(pc_palx20_mincount2.dge,normalized.lib.sizes=TRUE),center=TRUE,scale=TRUE)
  screeplot(pc_palx20.prc)
  #biplot(pc_palx20.prc)
  par(mfrow = c(1,1))
  
  allPCAs = cbind(palo.prc$sdev,palx30.prc$sdev,pc_palo.prc$sdev, pc_palx.prc$sdev, pc_palx20.prc$sdev)
  boxplot(log(allPCAs))
  allPCAs[1:20,]
  
  # If I replace 5000 genes with data drawn from a random normal distribution, does it affect the PCs?
#   temp = cpm(pc_palx20_mincount2.dge,normalized.lib.sizes=TRUE)
#   toPerturb = unique(runif(5000,min=1,max=nrow(temp)))
#   hist(log10(temp))
#   for(i in 1:length(toPerturb)){
#     temp[toPerturb[i],] = 10^rnorm(n=249,mean=3,sd=1)
#     }
#   hist(log10(temp), main = "data distribution after replacing some with simulated")
#   temp.prc = prcomp(temp, center=TRUE, scale=TRUE)
#   screeplot(temp.prc)
  
  return(pc_palo.prc)
}
```


Functions to calculate correlation with PCs and clinical/exp factors
```{r}
pcaCorrelation=function(x,y){cor.test(x,y)$p.value }
pcaCorrelationVal=function(x,y){cor.test(x,y)$estimate }
pcaLM=function(x,y){summary(lm(x ~ y))$coefficients[2,4]}

calc_plot_PC_corr=function(in.prc,inClinical=clinicalDataR){
  # Using correlation against eigenvectors from all PALO data
  clinicalPCAcorrelations = matrix(NA, nrow = nrow(in.prc$rotation), ncol = ncol(inClinical)-1)
  colnames(clinicalPCAcorrelations) = rep("default", ncol(clinicalPCAcorrelations))
  
  k = 1
  # correlate numeric factors on log scale
  toRun = c(5,10,15)
  for (j in k:length(toRun)) {
    clinicalPCAcorrelations[,j] = apply(in.prc$rotation,MARGIN=2,pcaCorrelation,y=log(inClinical[,toRun[j]]))
    colnames(clinicalPCAcorrelations)[j] = colnames(inClinical)[toRun[j]]
    }
  k = k + length(toRun) -1
  
  # correlate one numeric factor on non-log since it is already normal
  toRun = c(11)
  for (j in 1:length(toRun)) {
    clinicalPCAcorrelations[,k+j] = apply(in.prc$rotation,MARGIN=2,pcaCorrelation,y=inClinical[,toRun[j]])
    colnames(clinicalPCAcorrelations)[k+j] = colnames(inClinical)[toRun[j]]
    }
  k = k + length(toRun) 
  
  
  # correlate against all numeric dates
  toRun = c(8,9,12,13,14)
  for (j in 1:length(toRun)) {
    clinicalPCAcorrelations[,k+j] = apply(in.prc$rotation,MARGIN=2,pcaCorrelation,y=as.numeric(inClinical[,toRun[j]]))
    colnames(clinicalPCAcorrelations)[k+j] = colnames(inClinical)[toRun[j]]
    }
  k = k + length(toRun) 
  
  # regress against categorical factors
  toRun = c(6,7,16,17)
  for (j in 1:length(toRun)) {
    clinicalPCAcorrelations[,k+j] = apply(in.prc$rotation,MARGIN=2,pcaLM,y=inClinical[,toRun[j]])
    colnames(clinicalPCAcorrelations)[k+j] = colnames(inClinical)[toRun[j]]
    }
  
  op = par(mai = c(3,1,1,1))
  boxplot(clinicalPCAcorrelations[,1:13], las = 2)
  boxplot(t(clinicalPCAcorrelations[1:20,1:13]), las = 2, main = "Correlation of each PCs vs each factor", ylab = "raw pvalue")
  dotchart(t(clinicalPCAcorrelations[1:2,1:13]), xlab = "pvalue", main = "Correlation with PC1 and PC2",bg="tomato",lcolor="tomato",cex=1.1)
  dotchart(t(clinicalPCAcorrelations[1:2,1:13]), xlab = "pvalue", main = "Correlation with PC1 and PC2", xlim = range(0,0.1),bg="tomato",lcolor="tomato",cex=1.1)
  abline(v=0.05, lty = 2)
  abline(v = 0.01, lty = 3)
  #apply(clinicalPCAcorrelations[1:20,],MARGIN=1,stripchart, las = 2)
  par(op)
}
```


Function to correlate with alignment metrics
```{r}

calc_plot_alignPC_corr=function(in.prc,inAlign){
  # Using correlation against eigenvectors
  alignPCAcorrPval = matrix(NA, nrow = nrow(in.prc$rotation), ncol = ncol(inAlign))
  colnames(alignPCAcorrPval) = rep("default", ncol(alignPCAcorrPval))
  alignPCAcorrelations = matrix(NA, nrow = nrow(in.prc$rotation), ncol = ncol(inAlign))
  colnames(alignPCAcorrelations) = rep("default", ncol(alignPCAcorrelations))
  
  # correlate percentages and bias fractions
  for (j in 1:ncol(inAlign)) {
    alignPCAcorrPval[,j] = apply(in.prc$rotation,MARGIN=2,pcaCorrelation,y=inAlign[,j])
    colnames(alignPCAcorrPval)[j] = colnames(inAlign)[j]
    alignPCAcorrelations[,j] = apply(in.prc$rotation,MARGIN=2,pcaCorrelationVal,y=inAlign[,j])
    colnames(alignPCAcorrelations)[j] = colnames(inAlign)[j]
    }
  
  # Pvalues for the correlation test
  op = par(mai = c(3,1,1,1))
  boxplot(alignPCAcorrPval[,1:ncol(alignPCAcorrPval)], las = 2)
  par(op)
  boxplot(t(alignPCAcorrPval[1:15,1:ncol(alignPCAcorrPval)]), las = 2, main = "Correlation of each PCs vs each factor", ylab = "raw pvalue")
  dotchart(t(alignPCAcorrPval[1:2,1:ncol(alignPCAcorrPval)]), xlab = "pvalue", main = "Correlation with PC1 and PC2",bg="tomato",lcolor="tomato",cex=1.1)
  dotchart(t(alignPCAcorrPval[1:2,1:ncol(alignPCAcorrPval)]), xlab = "pvalue", main = "Correlation with PC1 and PC2", xlim = range(0,0.1),bg="tomato",lcolor="tomato",cex=1.1)
  abline(v=0.05, lty = 2)
  abline(v = 0.01, lty = 3)
  
  # Correlation values
  op = par(mai = c(3,1,1,1))
  boxplot(alignPCAcorrelations[,1:ncol(alignPCAcorrelations)], las = 2)
  par(op)
  boxplot(t(alignPCAcorrelations[1:15,1:ncol(alignPCAcorrelations)]), las = 2, main = "Correlation of each PCs vs each factor", ylab = "correlation estimate")
  dotchart(t(alignPCAcorrelations[1:2,1:ncol(alignPCAcorrelations)]), xlab = "correlation estimate", main = "Correlation with PC1 and PC2",bg="tomato",lcolor="tomato",cex=1.1, xlim=range(-1,1))
  abline(v = 0, lty = 3)
  
  
  # PC 3 and PC4
  dotchart(t(alignPCAcorrelations[3:4,1:ncol(alignPCAcorrelations)]), xlab = "correlation estimate", main = "Correlation with PC3 and PC4",bg="tomato",lcolor="tomato",cex=1.1, xlim=range(-1,1))
  abline(v = 0, lty = 3)
}

```


Results from multiple sailfish outputs
```{r}
align$sampNames = lookupRev$UDF.Investigator.Sample.Name[match(as.character(align$SAMPLE), lookupRev$Sample.Name)]
head(align)
metricsToCheck = c('MEDIAN_3PRIME_BIAS', 'MEDIAN_5PRIME_BIAS', 'MEDIAN_5PRIME_TO_3PRIME_BIAS', 'MEDIAN_CV_COVERAGE', 'PCT_CODING_BASES', 'PCT_CORRECT_STRAND_READS', 'PCT_INTEGENIC_BASES', 'PCT_INTRONIC_BASES', 'PCT_MRNA_BASES', 'PCT_USABLE_BASES', 'PCT_UTR_BASES')
alignToCheck = align[,which(colnames(align) %in% metricsToCheck)]

op = par(mfrow = c(3,3))
for (i in 1:ncol(alignToCheck)){ hist(alignToCheck[,i], main = colnames(alignToCheck)[i])}
par(op)
library(corrgram)
corrgram(alignToCheck,lower.panel = panel.pts,upper.panel = panel.pie)

# Estimated reads
tmp = generateDataAndClinicalObj('syn3064890')
data.dge = tmp$DGE
clinicalDataR = tmp$VARS
head(clinicalDataR)
clinicalDataR = clinicalDataR[match(colnames(data.dge),clinicalDataR$Px.Code),]
pc_palo.prc = generate_PCA_datasets(in.dge = data.dge)
calc_plot_PC_corr(in.prc = pc_palo.prc,inClinical = clinicalDataR)
calc_plot_alignPC_corr(in.prc = pc_palo.prc,inAlign = alignToCheck)

# Estimate Kmers
plot(1, main = "estimated Kmers")
tmp = generateDataAndClinicalObj('syn3098045')
data.dge = tmp$DGE
clinicalDataR = tmp$VARS
head(clinicalDataR)
clinicalDataR = clinicalDataR[match(colnames(data.dge),clinicalDataR$Px.Code),]
pc_palo.prc = generate_PCA_datasets(in.dge = data.dge)
calc_plot_PC_corr(in.prc = pc_palo.prc,inClinical = clinicalDataR)
calc_plot_alignPC_corr(in.prc = pc_palo.prc,inAlign = alignToCheck)


# TPM
# Using slighly different code, since this data is already TPM and doesn't need cpm transformation
plot(1, main = "TPM")
dataEntity = synGet('syn3064954') 
library('R.utils')
gunzip(getFileLocation(dataEntity),overwrite=TRUE)
x = unlist(strsplit(getFileLocation(dataEntity), split = '.gz'))
detach("package:R.utils", unload=TRUE)
estReads = read.csv(x, row.names = 1)
  
colnames(estReads) = lookupRev$UDF.Investigator.Sample.Name[match(colnames(estReads), paste("X", lookupRev$Sample.Name,sep = ""))]
casesStatus = rep("case", ncol(estReads))
casesStatus[which(colnames(estReads) %in% paste("X", controls, sep=""))] = "control"

data.dge = DGEList(counts=estReads,group=factor(casesStatus),remove.zeros=TRUE)
b = as.list(rownames(data.dge))
strippedNames = sapply(b,function(x){unlist(strsplit(as.character(x), split = "[.]"))[1]})
pc.dge = data.dge[which(strippedNames %in% proteinCoding_transcripts[,1]),]

head(clinicalDataR)
clinicalDataR = clinicalDataR[match(colnames(pc.dge),clinicalDataR$Px.Code),]
pc_palo.prc = prcomp(getCounts(pc.dge),center=TRUE,scale=TRUE)
screeplot(pc_palo.prc)
calc_plot_PC_corr(in.prc = pc_palo.prc,inClinical = clinicalDataR)
calc_plot_alignPC_corr(in.prc = pc_palo.prc,inAlign = alignToCheck)

```




Dispersion distribution and MDS on dispersion diffences
```{r}
# Look at dispersion across genes
plotDispersion=function(inDGE){
  inDGE$samples$group = factor(rep.int(1, length(inDGE$samples$group)))
  twd = estimateTagwiseDisp(estimateCommonDisp(inDGE), grid.length = 100)
  hist(twd$tagwise.dispersion)
}
palo.dge = estimateTagwiseDisp(estimateCommonDisp(palo.dge))
plotBCV(palo.dge)

pc_palo.dge = estimateTagwiseDisp(estimateCommonDisp(pc_palo.dge))
plotBCV(pc_palo.dge)

pc_palx_mincount2.dge = estimateTagwiseDisp(estimateCommonDisp(pc_palx_mincount2.dge))
plotBCV(pc_palx_mincount2.dge)
plotDispersion(inDGE=pc_palx_mincount2.dge)
length(which(pc_palx_mincount2.dge$tagwise.dispersion > 0.5))

plotCols = c("red", "blue")
pc_palx.mds = plotMDS(pc_palx_mincount2.dge, col = plotCols[as.numeric(pc_palx_mincount2.dge$samples$group)], method="bcv", top=2000, labels=as.numeric(pc_palx_mincount2.dge$samples$group))



pc_palx.cmd = cmdscale(pc_palx.mds$distance.matrix, eig = TRUE) 
barplot(pc_palx.cmd$eig)
hist(abs(pc_palx.cmd$eig))
hist(abs(pc_palx.cmd$eig), xlim = range(10,30), ylim = range(0,10),breaks = 20)
which(abs(pc_palx.cmd$eig) > 10)
```
